.. _glossary:

********
术语
********

.. if you add new entries, keep the alphabetical sorting!

.. glossary::

   ``>>>``
      Python 中交互式 shell 的默认提示符。常见于代码示例中，表示代码能在解释器中交互执行。

   ``...``
      在交互式 shell 中输入缩进的代码，或者在输入成对的左右分隔符之间时，Python 默认使用的提示符。

   2to3
      一个能尽可能把 Python 2.x 的代码转换成 3.x 格式的脚本，能够通过分析源代码及其语法树来检测并处理大部分不兼容的地方。

      2to3 在标准库中的模块名是 :mod:`lib2to3` ，它在 :file:`Tools/scripts/2to3` 中还有个独立的入口。参见 :ref:`2to3-reference` 。

   虚基类
      虚基类(ABC)是\ :term:`鸭子类型`\ 的典型例子，它提供了一种定义接口的方法；而这时其它的技巧，例如 :func:`hasattr` 等(如用\ :ref:`魔术方法<special-lookup>`)，都显得笨拙或有点错误。虚基类引入虚子类的概念，即一个类并没有继承另一个类，但仍可以通过 :func:`isinstance` 和 :func:`issubclass` 来识别，详见 :mod:`abc` 模块的文档。Python 内置了很多虚基类以用于数据类型(在 :mod:`collections.abc` 模块中)、数值(在 :mod:`numbers` 模块中)、数据流(在 :mod:`io` 模块中)、导入时搜索和加载(在 :mod:`importlib.abc` 模块中)。你也可以用 :mod:`abc` 模块创建自己的虚基类。

   实参
      在调用\ :term:`函数`\ (或者\ :term:`方法`)时所传递的值。实参有两种类型：

      * :dfn:`命名实参`\ ：在函数调用中带有标志符(例如 ``name=``)的参数，或者字典中键值前带有 ``**`` 的传入参数。例如下面调用 :func:`complex` 时 ``3`` 和 ``5`` 都是命名实参::

           complex(real=3, imag=5)
           complex(**{'real': 3, 'imag': 5})

      * :dfn:`位置实参`\ ：除了命名实参以外的实参。位置实参应该在实参列表的开始；或者作为\ :term:`可迭代对象`\ 的一个元素，这时它前面要带有 ``*`` 。例如下面调用 :func:`complex` 时 ``3`` 和 ``5`` 都是位置实参::

           complex(3, 5)
           complex(*(3, 5))

      在函数体内，实参会赋值给本地定义的变量，关于赋值的具体规则，参见\ :ref:`calls`\ 一节。从语法上来说，任何表达式都可以用作实参，它的结果值将会传给本地变量。

      另请参见术语词条\ :term:`形参`\ ，或者\ :ref:`实参和形参的区别<faq-argument-vs-parameter>`\ 处的常见问题，以及 :pep:`362` 。

   属性
      和某个对象相关联的一个值，可以用点表达式来引用。例如，如果有个对象 *o* 具有属性 *a* ，可以用 *o.a* 来引用。

   BDFL
      生命中仁慈的主(Benevolent Dictator For Life)，又称作 `Guido van Rossum <http://www.python.org/~guido/>`_ ，即 Python 的创始人。

   字节码
      Python 会被编译成字节码，这是 CPython 解释器对 Python 程序的内部表示形式。字节码还会缓存在 ``.pyc`` 和 ``.pyo`` 文件中，这样再次执行同样的文件就快多了(因为可以省略从源文件到字节码的编译过程)。这种"内部语言"在\ :term:`虚拟机`\ 上运行，并执行与字节码对应的机器码。要注意的是，把字节码移到其它 Python 虚拟机上，或者其它 Python 版本上面，不要指望它还能正常工作。

      关于字节码指令集，请参见 :ref:`dis 模块<bytecodes>`\ 的文档。

   类
      用来创建用户自定义对象的模板。类定义中通常包含方法的定义，用以操作类实例。

   隐式转换
      在要求两个运算数类型相同的运算中，一种类的实例转化为另外一种类的实例。例如，\ ``int(3.15)`` 把浮点数转化为整数 ``3`` ，但是在 ``3+4.5`` 中，运算数的类型各不相同(一个 int，一个 float)，所以在它们相加之前都要转化为相同的类型，否则就会抛出 ``TypeError`` 异常来。如果没有隐匿转换，即使是类型兼容的运算数也必须由程序员来转换。例如要写成 ``float(3)+4.5`` 而不是简单的 ``3+4.5`` 。

   复数
      这是您熟悉的实数系统的扩展，其中所有的数都表示为实部和虚部之和。虚数是虚数单位(``-1`` 的平方根，在数学中通常记为 ``i`` ，而在工程领域则记为 ``j``)与实数的积。Python 内置了对算数的支持，采用了第二种书写形式，即虚部带有 ``j`` 后缀，例如 ``3+1j`` 。和 :mod:`math` 模块相对应的算数模块是 :mod:`cmath` 。复数的使用是相当高等的数学中才会有的。如果你不知道哪里要用到它，就可以放心的忽略这些。

   上下文管理器
      在 :keyword:`with` 语句中用于管理环境的一个对象，它定义了 :meth:`__enter__` 和 :meth:`__exit__` 方法。参见 :pep:`343` 。

   CPython
      Python 编程语言的标准实现，发布在 `python.org <http://python.org>`_ 新闻组。"CPython" 这个词用来在必要的时候区别标准实现与其它实现，例如 Jython 或者 IronPython。

   修饰函数
      能够返回另外一个函数的函数，通常使用 ``@wrapper`` 的语法形式作为函数的转化器。常见的修饰函数有 :func:`classmethod` 和 :func:`staticmethod` 。

      修饰函数的语法只是一种语法简记形式。下面两种函数定义在语法上是等价的::

         def f(...):
             ...
         f = staticmethod(f)

         @staticmethod
         def f(...):
             ...

      同样的概念还见于类中，但是用得较少。详情参见文档\ :ref:`定义函数<function>`\ 和\ :ref:`定义类<class>`\ 。

   描述符
      一个定义了 :meth:`__get__` 、\ :meth:`__set__` 或者 :meth:`__delete__` 方法的对象。如果类属性是描述符，查找属性时就会触发特殊的绑定行为。通常，使用 *a.b* 的形式来获取、设置或删除一个属性时会在 *a* 的类字典中查找名字为 *b* 的对象，但如果 *b* 是个描述符，则会调用相应的描述符方法。理解描述符是深入理解 Python 的关键，因为它是很多功能的基础，例如函数、方法、属性、类方法、静态方法、以及对父类的引用。

      关于描述符的更多信息，参见\ :ref:`descriptors`\ 。

   字典
      一种关联数组，其中任意的键映射到值。键可以是带有 :meth:`__hash__` 和 :meth:`__eq__` 方法的对象。在 Perl 中称为哈希表。

   文档字符串
      作为类、方法、或者模块中第一个表达式出现的源字符串。跃然在代码块执行时会被忽略，编译器却会利用它并把它放在其所对应的类、方法、或模块的 :attr:`__doc__` 属性中。因为它能够通过自省来访问，所以就成了保存该对象文档的标准地方。

   鸭子类型
      一种编程风格，即不是根据一个对象的类型来决定其是否拥有正确的接口，而是直接调用其方法或访问其属性（"如果它看起来像鸭子，并且也像鸭子那样嘎嘎叫，那么它肯定是一只鸭子。")通过强调接口而不是具体的类型，设计良好的代码会通过多态性替换而变得灵活。鸭子类型避免了使用 :func:`type` 或者 :func:`isinstance` 来检测类型，(不过要注意的是，鸭子类型可以通过\ :term:`虚基类 <虚基类>` 来完善)，而是通常使用 :func:`hasattr` 来检测，或者使用 :term:`EAFP` 编程方法。

   EAFP
      请求谅解比获得权限更容易。这是 Python 的编程风格，它假定某个键名或属性是有效的，如果假设错误则通过捕获异常来处理。这种简捷快速的风格的特征是带有很多 :keyword:`try` 和 :keyword:`except` 语句。这和很多其它语言中使用的 `LBYL` 风格相对，例如 C 中的那样。

   表达式
      一段可以求值的语法结构。换句话说，一个表达式是由一系列表达式元素组成的，例如源常量、名称、属性访问、运算符、或者有返回值的函数调用。和其它语言不同的是，并非所有的语法结构都是表达式。还有些\ :term:`语句`\ 不能作为表达式使用，例如 :keyword:`if` 。赋值语法也是语句，而不是表达式。

   扩展模块
      使用 C 或者 C++ 编写的模块，它们通过 Python 的 C API 来和核心及用户代码交互。

   文件对象
      对底层资源提供面向文件 API (诸如 :meth:`read()` 或者 :meth:`write()` 的方法) 的对象。根据创建方式的不同，文件对象可以间接访问真实的磁盘文件，或者存储或通讯设备(例如标准输入/输出，内存中的缓存区，套接口，管道等)。文件对象又称作\ :dfn:`类文件对象`\ 或者\ :dfn:`流`\ 。

      文件对象事实上有三种类型：原始二进制文件，缓存二进制文件，以及文本文件。它们的接口都定义在 :mod:`io` 模块。创建文件的标准版方法是使用 :func:`open` 函数。

   类文件对象
      :term:`文件对象`\ 的同义词。

   查找器
      能够尽可能搜索一个模块的\ :term:`加载器`\ 对象。它必须实现一个叫 :meth:`find_loader` 或者 :meth:`find_module` 的方法。详情参见 :pep:`302` 以及 :pep:`420` ，或者 :class:`importlib.abc.Finder` 中的\ :term:`虚基类`\ 。

   下进位除法
      数学中的商向下进位到最近的整数。下进位除法的运算符是 ``//`` 。例如，表达式 ``11 // 4`` 值为 ``2`` 而真正的浮点数除法的值是 ``2.75`` 。注意 ``(-11) // 4`` 是 ``-3`` ，因为要把 ``-2.75`` *向下*\ 进位。参见 :pep:`238` 。

   函数
      一系列语句的集合，并向调用者返回某个值。在执行函数时可以向其传递零个或多个参数。另参见\ :term:`实参`\ 和\ :term:`方法`\ 。

   __future__
      一个伪模块，编程者可以用它来启用新的语法功能，而这些功能和当前的解释器是不兼容的。

      通过导入 :mod:`__future__` 模块并使用其中的变量，就可以看到一个新的功能是什么时候加入，又是什么时候成为语言中的默认功能的::

         >>> import __future__
         >>> __future__.division
         _Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)

   垃圾清理
      在内存不在使用时就把它释放的过程。Python 通过引用记数以及一个周期性运行的垃圾清理程序来进行垃圾清理，这个清理程序能够检测和打破引用循环。

      .. index:: single: 生成函数

   生成函数
      返回迭代器的函数。这个函数看起来像普通函数，只不过它含有 :keyword:`yield` 语句，能够产生一系列值，可以在 for 循环中通过 :func:`next` 函数每次获取一个。每个 :keyword:`yield` 都会暂停执行，并记住上次执行时的位置和状态(包括本地变量和暂停的 try 语句)。当生成器恢复执行时，它会从上次停止的地方开始执行(而不是像普通函数那样每次调用时都会从头开始执行)。

      .. index:: single: 生成函数表达式

   生成函数表达式
      返回值为迭代器的表达式。它看起来像普通表达式，但是后面带有一个 :keyword:`for` 表达式用来定义循环变量和范围，还有一个可选的 :keyword:`if` 表达式。这种表达式联合起来会在被包含的函数中生成一系列值::

         >>> sum(i*i for i in range(10))  # 平方和 0, 1, 4, ... 81
         285

   GIL
      参见\ :term:`解释器全局锁`\ 。

   解释器全局锁
      :term:`CPython` 解释器所使用机制，用来确保同一时刻只有一个线程执行 Python :term:`字节码`\ 。这就简化了 CPython 的实现，因为它使得对象模型(包括重要的内置类型，例如 :class:`dict`)默认对并发访问就是安全的。把整个解释器锁定可以让它更容易的进行多线程工作，这样做的代价是多核处理器要应付更多的并行处理。

      但是有一些模块的设计，有核心的也有第三方的，在处理计算密集型的任务时，例如压缩或者哈希运算，是要释放 GIL 。并且，在进行 I/O 操作时也总是释放 GIL 。

      以前曾试图创建一个"自由的多线程"解释器(能够在更细的粒度锁定共享数据)，但并没有取得多大成功，因为在常见的单处理器上性能非常差。大家认为，要解决这个性能问题需要把实现做得更复杂，所以维护成本也更高。

   可散列对象
      在一个对象的生命周期中，如果它的散列值从来不会改变(要有一个 :meth:`__hash__` 方法)，还可以和其它对象比较(需要有 :meth:`__eq__` 方法)，则说这个对象是\ *可散列的* 。比较结果相等的可散列对象必须有相同的散列值。

      可散列的特性使一个对象能够用作字典的键名，以及集合的元素，因为这些数据结构内部使用散列值。

      Python 中所有不可改变的内置对象都是可散列的，而任何可改变的容器(例如列表或字典)都不是。用户自定义类的对象实例默认都是可散列的，它们比较结果都是不相等的；它们的散列值是其 :func:`id` 。

   IDLE
      Python 集成开发环境。IDLE 是 Python 发行版中自带的基本编辑器及解释执行环境。

   不可变对象
      其值固定不变的对象。不可变对象包括数值，字符串和元组，它们都不能更改。如果要存储不同的值，必须创建新的对象。它们在需要散列常量值的地方起着重要作用，例如作为字典的键名。

   导入路径
      :term:`基于路径的查找器`\ 在导入模块时所搜索的位置列表(或者叫\ :term:`路径条目 <路径条目>`)。进行导入时，这个位置列表通常来自 :data:`sys.path` ，但对于子包也可以来自父包的 ``__path__`` 属性。

   导入
      Python 一个模块中的代码借此在另一个模块中使用的过程。

   导入器
      一个既能搜索又能加载模块的对象；它既是\ :term:`查找器`\ 又是\ :term:`加载器`\ 对象。

   交互式
      Python 有个交互式的解析器，这意味着你可以在解释器提示符下输入语句和表达式，让它们立即执行并看到运行结果。这只要运行 ``python`` 命令而不加参数(也有可能从你电脑的主菜单中选择)就可以了。这对于测试新的思路或检阅模块及包(记住要用 ``help(x)``)来说是非常强大的。

   解释型
      Python 是解释型语言而不是编译型的，尽管字节码编译器的存在，其区别已经很模糊。这意味着源文件可以直接运行而不需要先明确创建一个可执行程序然后再运行。解释型语言的开发/调试周期通常比编译型的短，尽管这些程序一般也运行得慢。参见\ :term:`交互式`\ 。

   可迭代对象
      可以每次返回其中一个元素的对象。可迭代对象的例子包括所有的序列类型(例如 :class:`list` 、\ :class:`str` 、\ :class:`tuple`)和一些非序列类型，如 :class:`dict` 和 :class:`file` ，还有你自己定义的类对象，只要它们有 :meth:`__iter__` 或者 :meth:`__getitem__` 方法。可迭代对象可以在 :keyword:`for` 循环语句和很多其它需要序列类型(:func:`zip` 、\ :func:`map` 、...)的地方使用。如果把一个可迭代对象作为形参传递给内置函数 :func:`iter` ，就会返回该对象的一个迭代器。这对于单次遍历一系列值而言是很好的。在使用可迭代对象时，通常都没有必要亲自调用 :func:`iter` 或者处理迭代器对象，\ ``for`` 语句会自动帮你完成，并在循环过程中创建一个临时变量来保存迭代器。参见 :term:`迭代器`\ 、\ :term:`序列` 和 :term:`生成函数`\ 。

   迭代器
      代表一个数据流的对象。连续调用迭代器的 :meth:`~iterator.__next__` 方法(或者连续把它传给内置函数 :func:`next`)会相继返回流中的数据项。如果没有数据可用，则抛出 :exc:`StopIteration` 异常。这时，迭代器对象已经穷尽，如果继续调用其 :meth:`__next__` 方法就会再次抛出 :exc:`StopIteration` 异常。迭代器必须要有 :meth:`__iter__` 方法，这个方法要返回迭代器本身，所以每个迭代器都是可迭代对象，在可以使用其它可迭代对象的大部分对方也可以用迭代器。这里有个异常值得关注，就是试图多次遍历数据的代码。每当把容器对象(例如 :class:`list`)传给 :func:`iter` 函数或者在 :keyword:`for` 循环中使用时都会产生一个新的迭代器。如果这样使用迭代器，则会返回同样已经上次遍历中穷尽的迭代器对象，这使得它像一个空的容器。

      更多信息参见\ :ref:`typeiter`\ 。

   关键字函数
      关键字函数，又叫整理函数，是一个返回值可以用来排序的函数。例如，:func:`locale.strxfrm` 被用来生成一个排序键值，这个值知道语言区域相关的惯例。

      Python 中有许多函数接受关键字函数来控制元素的排序或者分组，包括 :func:`min` 、\ :func:`max` 、\ :func:`sorted` 、\ :meth:`list.sort` 、\ :func:`heapq.nsmallest` 、\ :func:`heapq.nlargest` 、以及\ :func:`itertools.groupby` 。

      创建关键字函数的方法有好几种。例如，\ :meth:`str.lower` 方法可以作为不区分大小写排序的关键字函数。还可以用 :keyword:`lambda` 表达式临时创建一个关键字函数，例如 ``lambda r: (r[0], r[2])`` 。此外，\ :mod:`operator` 模块提供了三个关键字函数构造方法：\ :func:`~operator.attrgetter` ，\ :func:`~operator.itemgetter` 和 :func:`~operator.methodcaller` 。关于如何创建和使用关键字函数，参见\ :ref:`怎么排序<sortinghowto>` 。

   命名实参
      参见\ :term:`实参`\ 。

   lambda
      匿名的内联函数，只包含一个\ :term:`表达式`\ ，在调用该函数时会对这个表达式进行求值。创建一个 lambda 函数的语法是 ``lambda [arguments]: expression`` 。

   LBYL
      看看周围环境再跳跃。这种编程风格在调用方法或者查找属性前明确检测前提条件。它和 :term:`EAFP` 方法相对，其特征是有很多 :keyword:`if` 语句。

      在多线程环境中，LBYL 方法可能引发"查看者"和"跳跃者"之间的竞争状态。例如，在代码 ``if key in mapping: return mapping[key]`` 中，如果另一个线程在检测过后查找之前把 *key* 从 *mapping* 删除掉。这种情况可以通过锁或者 EAFP 方法解决。

   列表
      Python 内置的一种\ :term:`序列`\ 类型。尽管这个名字有其它含义，它和其它语言中的数组更相近，而不是链表，因为它访问元素的复杂度是 O(1)。

   列表解析
      处理序列中所有或者部分元素的一种紧凑形式，结果返回一个列表。\ ``result = ['{:#04x}'.format(x) for x in range(256) if x % 2 == 0]`` 生成一个字符串列表，包括了从 0 到 255 之间的十六进制偶数(0x..)。这里的 :keyword:`if` 子句是可选的；如果省略，则会处理 ``range(256)`` 中的所有元素。

   加载器
      能加载模块的对象，它必须定义 :meth:`load_module` 方法。加载器通常是由\ :term:`查找器`\ 返回的。详情参见 :pep:`302` 或者 :class:`importlib.abc.Loader` 中的\ :term:`虚基类`\ 。

   映射
      一个容器对象，支持用任意键名访问，并实现了 :class:`~collections.abc.Mapping` 或者 :class:`~collections.abc.MutableMapping` :ref:`虚基类<collections-abstract-base-classes>`\ 中指定的方法。例如 :class:`dict` 、\ :class:`collections.defaultdict` 、\ :class:`collections.OrderedDict` 和 :class:`collections.Counter` 。

   元路径查找器
      在 :data:`sys.meta_path` 找到的查找器，它和\ :term:`路径条目查找器 <路径条目查找器>`\ 有关系，但又不一样。.

   元类
      类之类，即定义了类名、类字典、一系列基类的类。元类负责利用这三个参数创建一个类。许多面向对象的编程语言提供了默认的元类实现，而 Python 的特别之处在于它允许创建自定义元类。大部分用户都不需要这个东西，但在需要的时候它就能提供很强大和优雅的方案。它们已经被用来记录属性访问、增加线程安全性、跟踪对象创建、实现单例模式以及很多其它的任务。

      更多信息参见\ :ref:`metaclasses`\ 。

   方法
      在类范围内定义的函数。如果作为该类实例的属性来调用，这个实例对象将是方法的第一个\ :term:`实参`\ (这个参数通常叫 ``self``)。参见\ :term:`函数`\ 和\ :term:`嵌套作用域`\ 。

   方法解析顺序
      方法解析顺序是指在基类中查找一个方法时所用的顺序。参见 `Python 2.3 中的方法解析顺序 <http://www.python.org/download/releases/2.3/mro/>`_ 。

   模块
      Python 代码的组织单位，也是一个对象。模块定义了一个命名空间，其中可以包含任意的 Python 对象。它是通过\ :term:`导入`\ 过程加载到 Python 中的。

   MRO
      参见\ :term:`方法解析顺序`\ 。

   可变对象
      可变对象的值可以改变而保持相同的 :func:`id` 。参见\ :term:`不可变对象`\ 。

   命名元组
      任意像类一样的元组，其可用下标访问的元素也可以通过命名属性访问(例如 :func:`time.localtime` 返回像元组一样的对象，其 *year* 属性既可以用下标访问 ``t[0]`` 也可以用命名属性访问 ``t.tm_year``)。

      命名元组可以是内置类型，例如 :class:`time.struct_time` ，也可以用普通的类定义的方法创建。功能完整的命名元组还可以用工厂函数 :func:`collections.namedtuple` 来创建。最后这种方法自动提供了一些额外的功能，例如像 ``Employee(name='jones', title='programmer')`` 的自我解释形式。

   命名空间
      存储变量的地方。命名空间通过字典实现，它们有局部的、全局的、内置的、以及对象(方法)中嵌套的。命名空间避免了名称冲突，从而支持模块化。例如，函数 :func:`builtins.open` 和函数 :func:`os.open` 通过其命名空间得以区别。命名空间还明确指示一个函数在哪个模块中实现，因而增强可读性和可维护性。例如，\ :func:`random.seed` 和 :func:`itertools.islice` 这两个不同的写法说明这两个函数分别是 :mod:`random` 和 :mod:`itertools` 模块实现的。

   包空间
      遵循 :pep:`420` 的\ :term:`包`\ ，其作用只是作为子包的容器。包空间可以没有物理包结构，尤其是不像\ :term:`普通包`\ 那样包含 ``__init__.py`` 文件。

   嵌套作用域
      能够引用在嵌套外围定义的变量。例如，在另外一个函数之内定义的函数能够引用其外部的变量。注意，默认情况下嵌套作用域只对引用有效，而对赋值无效。本场变量在嵌套最内层既可读也可写；类似的，全局变量在全局空间也是可读可写的。\ :keyword:`nonlocal` 可以对外围的变量写入。

   新式类
      目前所有类对象都使用的风格，这是以前的称呼。在 Python 以前的版本中，只有新式的类才可以使用 Python 中新的强化功能，例如 :attr:`__slots__` 、描述符、属性、\ :meth:`__getattribute__` 、类方法、以及静态方法。

   对象
      任何包含状态(属性或值)和既定行为(方法)的数据。object 也是所有\ :term:`新式类`\ 的最终基类。

   包
      Python 中的模块，可以包含子模块或者递归的子包。从技术上说，包是指含有 ``__path__`` 属性的 Python 模块。

   形参
      :term:`函数`\ (或者方法)定义中的命名实体，指定该函数能够接受的\ :term:`实参`\ (有时可以是多个实参)。形参有五种类型：

      * :dfn:`位置形参或关键字形参`\ ：指定可以接受的\ :term:`位置实参 <实参>`\ 或者\ :term:`关键字实参 <实参>`\ 。这是默认的形参类型，例如下面的 *foo* 和 *bar*::

           def func(foo, bar=None): ...

      * :dfn:`只用置形参`\ ：指定只能通过位置传入的实参。Python 中没有特殊的语法定义只用位置形参的函数，但有些内置函数却只有位置形参(例如 :func:`abs`)。

      * :dfn:`只用关键字形参`\ ：指定只能通过关键字传入的实参。关键字形参在定义时可以在函数的形参列表中先指定前面仅有的可变位置形参或单独的 ``*`` ，例如下面的 *kw_only1* 和 *kw_only2*::

           def func(arg, *, kw_only1, kw_only2): ...

      * :dfn:`可变位置形参`\ ：指定可以传入任意个数的位置实参(除了其它形参已经接受的任何位置形参)。这种形参可以通过在形参名称前加上 ``*`` 来定义，例如下面的 *args*::

           def func(*args, **kwargs): ...

      * :dfn:`可变关键字形参`\ ：指定可以传入任意个数的关键字实参(除了其它形参已经接受的任何关键字形参)。这种形参可以通过在形参名称前面加上 ``**`` 来定义，例如上面例子中的 *kwargs* 。

      形参声明的实参既可以是可选的，也可以是必须的；它还可以为一些可选实参指定默认值。

      参见术语条目\ :term:`实参`\ 、\ :ref:`实参和形参的区别<faq-argument-vs-parameter>`\ 处的常见问题、\ :class:`inspect.Parameter` 类、\ :ref:`functions` 、以及 :pep:`362`\ 。

   路径条目
      :term:`导入路径`\ 中的单个位置；\ :term:`基于路径的查找器`\ 用它来查找要导入的模块。

   路径条目查找器
      :data:`sys.path_hooks` (即\ :term:`路径条目钩子`)中可调用对象返回的\ :term:`查找器`\ ，它知道怎么在给定\ :term:`路径条目`\ 中查找模块。

   路径条目钩子
      :data:`sys.path_hook` 列表中的可调用对象，如果它知道怎么在指定的\ :term:`路径条目`\ 找到模块就会返回一个\ :term:`路径条目查找器`\ 。

   基于路径的查找器
      默认的\ :term:`元路径查找器 <元路径查找器>`\ 之一，可以在\ :term:`导入路径`\ 中搜索模块。

   包块
      构成包空间的单个目录(可能存储在 zip 文件中)中的一系列文件，参见 :pep:`420` 中的定义。

   位置实参
      参见\ :term:`实参`\ 。

   临时包
      临时包是故意不像一般标准库那样保证向后兼容性的包。这些包在标记为临时包的时候，虽然不会有大的改变，但如果核心开发人员认为有必要，有些改变可以不向后兼容(不兼容到去掉这个包为止)。当然这些改变不是随意，而是在发现包中的重大、收录之前没有发现的缺陷后才进行的。

      这个过程可以让标准库随着时间的推移持续的演化，而不会在长时间内保留错误的设计。详情参见 :pep:`411`\ 。

   Python 3000
      Python 3.x 发行系统的别名(在第三版还远未形成之前就已经创造了这个词)，也简称为 "Py3k"。

   Pythonic
      遵循 Python 语言中最常见习惯的观点或代码，而不是其它语言中常见概念的翻版。例如，Python 中一个常见的做法就是使用 :keyword:`for` 循环来遍历可迭代对象的所有元素；很多其它语言没有这样的语法结构，所以不熟悉 Python 的有时会使用计数器::

          for i in range(len(food)):
              print(food[i])

      而不是更简洁的 Pythonic 方法::

         for piece in food:
             print(piece)

   限定名字
      带点号的名字，根据 :pep:`3155` ，显示了从模块的全局作用域到该模块中的类、函数、方法等的"路径"。对于全局的函数和类，其限定名字和该对象的名字是一样的::

         >>> class C:
         ...     class D:
         ...         def meth(self):
         ...             pass
         ...
         >>> C.__qualname__
         'C'
         >>> C.D.__qualname__
         'C.D'
         >>> C.D.meth.__qualname__
         'C.D.meth'

      如果针对模块，则\ *完整的限定名字*\ 指到模块的完整带点号路径，包括任何父包。例如 ``email.mime.text``::

         >>> import email.mime.text
         >>> email.mime.text.__name__
         'email.mime.text'

   引用计数
      一个对象被引用的次数。如果引用的次数降至零，这个对象就会被释放。对 Python 代码而言，引用计数通常是不可见的，但却是 :term:`CPython` 实现的核心成分之一。\ :mod:`sys` 模块定义了一个 :func:`~sys.getrefcount` 函数，程序员用它可以得到某个指定对象的引用计数。

   普通包
      传统的\ :term:`包`\ ，例如包含 ``__init__.py`` 文件的目录。

   __slots__
      类中一种声明，旨在通过为实例属性预定义空间并去除实例的字典来节约内存。它虽然很流行，想正确使用却需要一些技巧，最好在那些内存吃紧而实例数目众多的极少数应用中使用。

   序列
      一种\ :term:`可迭代对象`\ ，支持通过特殊方法 :meth:`__getitem__` 而使用整数序号来有效访问其元素，并定义了 :meth:`__len__` 方法来返回序列的长度。内置的序列类型有 :class:`list` 、\ :class:`str` 、\ :class:`tuple` 、\ 和 :class:`bytes` 。注意，虽然 :class:`dict` 也支持 :meth:`__getitem__` 和 :meth:`__len__` 方法，即被当成映射而不是序列，因为它在查找时使用任意的\ :term:`不可变对象`\ 作为键名，而不是用整数序号。

   切片
      包含\ :term:`序列`\ 中部分元素的对象。切片通过使用下标的方法来创建，即 ``[]`` 中间带有冒号用来分隔的旁边可能存在的数字，例如 ``variable_name[1:3:5]`` 。这种方括号的下标用法在背后使用了 :class:`slice` 对象。

   特殊方法
      Python 中隐式调用的方法，用来对某种类型进行特定的操作，例如加法。这些方法的名称前后都有双下划线。其文档参见\ :ref:`specialnames` 。

   语句
      语句是代码块的一部分，它要么是个\ :term:`表达式`\ 要么是几种带有关键字的语法结构之一，例如 :keyword:`if` 、\ :keyword:`while` 或者 :keyword:`for` 。

   结构体序列
      带有命名元素的元组。结构体序列的界面和\ :term:`命名元组`\ 类似，其元素既可以通过序号来访问，也可以通过属性来访问；但是它们没有命名元组的任何方法，例如 :meth:`~collections.somenamedtuple._make` 或者 :meth:`~collections.somenamedtuple._asdict` 。结构体序列的例子有 :data:`sys.float_info` 以及 :func:`os.stat` 的返回值。

   三引号字符串
      一个字符串，其前后有三个双引号(")或者三个单引号(')限定。虽然它们并不比单引号字符串多任何功能，却因为一些原因而很有用。它鸡毛在字符串中包含没有转义的单引号或者双引号，它们可以连续多行而不需要续行符，这使得它们尤其适合作为文档字符串。

   类型
      Python 对象的类型决定了它是什么样子的。每个对象都有类型，并且通过其 :attr:`__class__` 属性来访问，还可以通过 ``type(obj)`` 来获取。

   万能换行符
      文本流的一种解释方法，即把下面各种情况都当成行结束：Unix 的行结束习惯 ``'\n'`` 、Windows 习惯 ``'\r\n'`` 、以及旧式的 Macintosh 习惯 ``'\r'`` 。参见 :pep:`278` 和 :pep:`3116` ，以及 :func:`str.splitlines` 中的更多用法。

   视图
      :meth:`dict.keys` 、\ :meth:`dict.values` 、以及 :meth:`dict.items` 返回的对象叫做字典的视图。它们是惰性序列，可以看到其背后字典的改变。可以通过 ``list(dictview)`` 来强制把字典试图变成一个列表。参见\ :ref:`dict-views` 。

   虚拟机
      完全用软件定义的计算机。Python 虚拟机可以执行字节码编译器生成的\ :term:`字节码`\ 。

   Python 之道
      Python 设计原则和哲理总结，有助于理解和使用该语言。可以在交互式提示符下输入 ``import this`` 来看到这些信息。
